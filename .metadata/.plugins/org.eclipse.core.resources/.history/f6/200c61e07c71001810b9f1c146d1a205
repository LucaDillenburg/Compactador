package compactador;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Arrays;

import codigo.*;

import arvore.*;

import ListaDesordenada.*;

public class Compactador
{
	public class FreqSimb
	{
	   protected int freq;
	   protected int simb;

		public FreqSimb(int f)
	   	{
	      	this(f, -1);
	   	}

	   	public FreqSimb(int f, int s)
	   	{
	    	this.freq = f;
	      	this.simb = s;
	   	}

	   	public int getSimb()
	   	{
	    	return this.simb;
	   	}

	   	public int getFreq()
	   	{
	    	return this.freq;
	   	}
	   	
	   	public String toString()
	   	{
	   		return "Frequencia: " + this.getFreq() + " Simbolo: " + this.getSimb();
	   	}
	}

	protected Codigo[] codigos;
	protected RandomAccessFile arq;

	public Compactador()
	{}

	protected byte[] arquivoParaVetor(String nomeArquivo)
	{
		try
		{

			this.arq = new RandomAccessFile(nomeArquivo, "r");

			int qtd = (int)this.arq.length();
			byte[] v = new byte[qtd];
			for(int i=0; i<qtd; i++)
			{
				int n = this.arq.read();
				if(n>127)
					v[i] = (byte) (n - 256);
				else	
					v[i] = (byte)n;
				
				if(n<0)
					n += 256;
			}

			//int qtd = arq.read(v);
			this.ajustarTamVet(v, qtd);
			
			try 
			{
				this.arq.close();
			} 
			catch (IOException e) 
			{
				e.printStackTrace();
			}
			
			return v;
		}catch(Exception e) {}
		
		return new byte[0];
	}

	protected void salvarVetArq(byte[] nvVet, String nomeArquivo)
	{
		try 
		{
			this.arq = new RandomAccessFile(nomeArquivo, "rw");
			
			this.arq.write(nvVet);
		} catch (IOException e)
		{
			e.printStackTrace();
		}
		try 
		{
			this.arq.close();
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
	}
	
	protected void salvarVetArq(byte[][] nvVet, String nomeArquivo)
	{
		byte[] ret;
		int qtd = 0;
		
		
		for (int i = 0; i < nvVet.length; i++)
			qtd += nvVet[i].length;
		
		ret = new byte[qtd];
		
		int atual = 0;
		
		for (int i = 0; i < qtd; i++)
			for(int j = 0; j < nvVet[i].length; j++)
			{
				ret[atual] = nvVet[i][j];
				atual++;
			}
				
		salvarVetArq(this.ajustarTamVet(ret, qtd), nomeArquivo);
	}

	public void compactar(String nomeArquivo) throws Exception
	{	
		if(!new File(nomeArquivo).exists())
			throw new Exception("Arquivo inexistente!");
		
		//transforma o arquivo em byte[]
		byte[] v = this.arquivoParaVetor(nomeArquivo);
		FreqSimb[] vFreq = vByteParaVFreq(v);
		Arvore<FreqSimb> arv = vFreqParaArv(vFreq);
		this.codigos = new Codigo[256];
		
		for(int i = 0; i < 256; i++)
			this.codigos[i] = new Codigo();

		this.codigos = arv.montarVetor();
		//transformar v de acordo novos codigos:

		//cabecalho:
		// (1)- qtd bits inuteis no final do ultimo byte
		// (2)- quantidade de codigos diferentes
		// (3)- codAnt, freq (2 bytes)

		ListaDesordenada<Byte> nvVet = new ListaDesordenada<Byte>();
		
		int qtdDifCods = 0;
		int z = 2;
		for(int i=0; i < vFreq.length; i++)
			if(vFreq[i].getFreq() != 0)
			{
				//(3)
				nvVet.insiraNoFim((byte) vFreq[i].getSimb());//char
				
				z++;
				byte[] aux =  arv.acharElemento(vFreq[i].getSimb());
				nvVet.insiraNoFim((byte) aux.length);//bits que o código ocupa
				for(int j = 0; j < aux.length; j++)
				{
					z++;
					nvVet.insiraNoFim(aux[j]);//O código em bits
				}
				
				z++;
				
				qtdDifCods++;
			}
		
		for(int i=0; i < v.length; i++)
		{
			//nvVet.insiraNoFim(v[i]);
			//z++;
			
			byte[] sAux = arv.acharElemento(v[i]);
			
			for(int y = 0; y < sAux.length; y++)
			{
				
				nvVet.insiraNoFim(sAux[y]);
				z++;
			}
			
		}

		nvVet.insiraNoInicio((byte) qtdDifCods);
		
		String str = "";
		
		int j = nvVet.Length();

		byte[] aux = toArray(nvVet,true);
		
		for(int i = 0; i < aux.length; i++)
			str += aux[i];
		
		aux[0] = (byte) (str.length() % 8);
		
		//escreve o vetor de byte no arquivo
		nomeArquivo  = nomeArquivo.substring(0, nomeArquivo.indexOf('.'));
		nomeArquivo += ".MrSaturn";
		this.salvarVetArq(aux, nomeArquivo);
		
	}

	private byte[] toArray(ListaDesordenada<Byte> l, boolean ehComp) 
	{
		int aux = l.Length();
		byte[] ret = new byte[aux + 1];
		
		for (int i = ehComp ? 1 : 0; i < aux + (ehComp ? 1 : 0); i++)
		{
			ret[i] = l.getPrimeiro();
			try 
			{
				l.jogueForaPrimeiro();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} 
		return ret;
	}

	public void descompactar(String nomeArquivo) throws Exception
	{
		if(!new File(nomeArquivo).exists())
			throw new Exception("Arquivo inexistente!");
		
		//transforma o arquivo em byte[]
		byte[] vet = this.arquivoParaVetor(nomeArquivo);

		byte qtdBitsFinal = vet[0];
		byte qtdDifCods = vet[1];

		byte[][] vCodigo   = new byte[qtdDifCods][];
		byte[] codNormal  = new byte[qtdDifCods];
		
		int z = 2;
		
		for (int i = 0; i < qtdDifCods; i++)
		{
			codNormal[i] = vet[z];
			
			z++;
			
			int j;
			vCodigo[i] = new byte[vet[z] & 0xff];
			
			for(j = 1; j < (vet[z] & 0xff); j++)
			{
				vCodigo[i][j - 1] = vet[z + j];  
			}
			z+=j;
		}
		ListaDesordenada l = new ListaDesordenada();
		
		String str = "";
		
		for(int i = 0; str.length() != 0; i++)
		{  
			String aux = "";
			
			o: for (int j = 0; ; j++)
			{
				aux = str.substring(0, j);
				for(int u = 0; ; u++)
					if(new Codigo(vCodigo[u]).toString().equals(aux))
					{
						l.insiraNoInicio(codNormal[u]);
						break o;
					}
					
			}
		}
		//escreve o vetor de byte no arquivo
		nomeArquivo  = nomeArquivo.substring(0, nomeArquivo.indexOf('.'));
		nomeArquivo += ".DesMrSaturn";
		this.salvarVetArq(toArray(l, false), nomeArquivo);
	}

	protected byte bitEspByte(byte b, byte n)
	{
		//0000   - 0
		//0001   - 1
		//0010   - 2
		//0011   - 3
		//0100   - 4
		//0101   - 5
		//0110   - 6
		//0111   - 7
		//1000   - 8
		//1001   - 9
		//1010   - A
		//1011   - B
		//1100   - C
		//1101   - D
		//1110   - E
		//1111   - F

		return (byte)((b >> (8-n)) & 0x01);
	}

	protected byte[] ajustarTamVet(byte[] vetor, int qtd)
	{
		byte[] aux = new byte[qtd];

		for (int i=0; i < qtd; i++)
			aux[i] = vetor[i];

		return aux;
	}
	
	protected byte[][] ajustarTamVet(byte[][] vetor, int qtd)
	{
		byte[][] aux = new byte[qtd][];

		for (int i=0; i<qtd; i++)
			aux[i] = vetor[i];

		return aux;
	}

	protected void aumentarTamVet(byte[][] vetor)
	{
		byte[][] aux = new byte[(int) (vetor.length*1.5%1)][];
		for(int i=0; i<vetor.length; i++)
			aux[i] = vetor[i];

		vetor = aux;
	}
	
	protected void aumentarTamVet(byte[] vetor)
	{
		byte[] aux = new byte[(int) (vetor.length*1.5%1)];
		for(int i=0; i<vetor.length; i++)
			aux[i] = vetor[i];

		vetor = aux;
	}
	
	/*arv.colocarAtualNaRaiz();
	
	if(arv.getAtual() != null)
	{
		if(((FreqSimb) arv.getAtual()).getFreq() != 0)
			this.codigos[((Codigo) arv.getAtual()).getByte()] = (Codigo)c.clone();
		else
		{
			c.mais(0);
			
			try {
				arv.andarAtualEsq();
			} catch (Exception e) {}
			
			this.montarVetor(arv, c);
			c.tirarUltimo();
			c.mais(1);
			
			try {
				arv.andarAtualDir();
			} catch (Exception e) {}
			
			this.montarVetor(arv, c);
			c.tirarUltimo();
		}
	}*/

	protected FreqSimb[] vByteParaVFreq(byte[] v)
	{

		FreqSimb[] vFreq = new FreqSimb[256];
		for(int i=0; i < 256; i++)
	    	vFreq[i]   = new FreqSimb(0);
		
	    for(int i=0; i < v.length; i++)
	    {
	    	int j = 0;
	    	for(;vFreq[j].getFreq() != 0; j++)
	    		if(v[i] == vFreq[j].getSimb())
	    			break;
	    	
	    	if (vFreq[j].getFreq() == 0)
	    		vFreq[j].simb = v[i];
	
	    	vFreq[j].freq++;
	    }
	    
	    //vFreq = ordenaVetor(vFreq);
	    	
	    return vFreq;
	}

	private FreqSimb[] ordenaVetor(FreqSimb[] vFreq) 
	{
		for(int z = 0; z < vFreq.length; z++)
		{
			int oMaior = z;
			for(int i = z; i < vFreq.length; i++)
				if(vFreq[i].getFreq() > vFreq[oMaior].getFreq())
					oMaior = i;
			
			FreqSimb aux = vFreq[z];
			vFreq[z] = vFreq[oMaior];
			vFreq[oMaior] = aux;
		}
		return vFreq;
	}

	protected Arvore<FreqSimb> vFreqParaArv(FreqSimb[] vFreq)
	{
	   	Object[] arvs = new Object[256];
	   	int qtd = 0;

	   	for(int i=0; i<vFreq.length; i++)
	    	if(vFreq[i].getFreq() != 0)
	      	{
	    		Arvore<FreqSimb> aux = new Arvore<FreqSimb>();
	    		
	    		try 
	    		{
					aux.inserirNoInicio(vFreq[i]);
				} 
	    		catch (Exception e) 
	    		{
	    			e.printStackTrace();
	    		}
	    		
	      		arvs[i] = aux;
	         	qtd++;
	         	
	         	
	        	Compactador.mudarPosArvs(arvs, qtd);
	      	}

	   	for(; qtd>1; qtd--)
	   	{
	   		System.out.println(Arrays.toString(arvs));
	    	Compactador.mudarPosArvs(arvs, qtd);

	      	Arvore<FreqSimb> aux = new Arvore<FreqSimb>();
	      	
	      	try 
	      	{
	      		((Arvore<FreqSimb>) arvs[qtd-2]).colocarAtualNaRaiz();
	      		((Arvore<FreqSimb>) arvs[qtd-1]).colocarAtualNaRaiz();
	      		
				aux.inserirNoInicio(new FreqSimb(((Arvore<FreqSimb>) arvs[qtd-2] ).getAtual().getFreq() + ((Arvore<FreqSimb>) arvs[qtd-1]).getAtual().getFreq() ) );
			} 
	      	catch (Exception e)
	      	{
	      		e.printStackTrace();
	      	}
	      	
	      	if(qtd>1)
	      	{
	      		System.out.println(qtd);
	      		aux.juntar((Arvore<FreqSimb>)arvs[qtd-2], (Arvore<FreqSimb>)arvs[qtd-1]);
	      		arvs[qtd-1] = null;
	      		
	      		arvs[qtd-2] = aux;
	      	}
	      	
	   
	   	}
	   	
	   	System.out.println(arvs[0]);
	   	
	   	return (Arvore<FreqSimb>) arvs[0];
	}
	
	/*protected Arvore vCodigoParaArvore(byte[] codNorm, byte[][] representacao)
	{
		Arvore ret = new Arvore();
		for (int i = 0; i < codNorm.length; i++)
		{
			for (int j = 0; j < representacao[i].length; j++)
			{
				
			}
		}
	}*/

	//deixa o ultimo na posicao certa
	protected static void mudarPosArvs(Object[] arvs, int qtd)
	{
	   	for(int i = qtd-1; i > 0; i--)
	   	{
	   		((Arvore<FreqSimb>) arvs[i]).colocarAtualNaRaiz();
	   		((Arvore<FreqSimb>) arvs[i-1]).colocarAtualNaRaiz();
	   		if (((Arvore<FreqSimb>) arvs[i]).getAtual() != null)
	   		{
	   			if(((Arvore<FreqSimb>) arvs[i]).getAtual().getFreq() <= ((Arvore<FreqSimb>) arvs[i-1]).getAtual().getFreq())
	   				break;
	   			else
	   			{	
	   				Arvore<FreqSimb> aux = (Arvore<FreqSimb>) arvs[i];
	   				arvs[i] = arvs[i-1];
	   				arvs[i-1] = aux;
	   			}
	   		}
	   	}

	   	//"arvs" saira diferente (como passagem por referencia)
	}
}